âœ³(ns respatialized.colors.extraction
  (:require [tech.v3.tensor :as tensor]
            [tech.v3.datatype :as dtype]
            [tech.v3.datatype.functional :as dtype-fn]
            [tech.v3.libs.buffered-image :as dtype-img]
            [clojure.data.json :as json]
            [clojure.java.io :as io]
            [respatialized.colors :as colors]
            [garden.core :as garden]
            [applied-science.darkstar :as darkstar])) ðŸ”š

âœ³(def metadata {:title "Color Extraction Through Curve Fitting"})ðŸ”š

âœ³=[:h1 (:title metadata)]ðŸ”š

I would like to extract colors from an image. In so doing, I would like to meet two requirements:
âœ³= [:dl [:dt "Recognizability"] [:dd "The colors should be representative of the \"dominant\" colors in the image."]
  [:dt "Contrast"] [:dd "The levels of contrast in the palette extracted should respect accessibility guidelines for appropriate levels of contrast."]] ðŸ”š

This can be thought of as a constraint-based optimization problem: how can I fit a perceptual curve to the colors in an image?

âœ³=[:h2 "Example images"]ðŸ”š

Some public domain artwork will serve as a good starting point.

âœ³(def example-images [{:title "Carpente" :year 1944 :artist "Reijer Stolk" :img/url "https://live.staticflickr.com/65535/51913654989_7490d04a5a_4k.jpg"
:source "https://www.flickr.com/photos/vintage_illustration/51913654989/in/album-72177720297063629/"}
{:title "New York from the 34th Street Ferry" :year 1914 :artist "Rachael Robinson Elmer" :img/url "https://media.nga.gov/iiif/e848d2b4-72bb-4abc-8812-4aa2ab291d42/full/full/0/default.jpg" :source "https://www.nga.gov/collection/art-object-page.147966.html"}] )ðŸ”š

âœ³= (apply conj [:div]
     (for [{:keys [title artist img/url source year]} example-images]
       [:figure [:img {:src url}] [:figcaption [:a {:href source} title] " by " artist ", " year]]))ðŸ”š

âœ³=[:h2 "Contrast guidelines"]ðŸ”š

The US General Services Administration has a short âœ³=[:a {:href "https://accessibility.digital.gov/visual-design/color-and-contrast/"} "explainer site"]ðŸ”š on color contrast for accessibility purposes:

âœ³=[:blockquote "Make sure the contrast between the text and background is greater than or equal to 4.5:1 for small text and 3:1 for large text."]ðŸ”š

This requirement is relaxed for non-essential elements:

âœ³=[:blockquote "Color contrast ratio requirements apply to text and graphics that are essential for understanding the content or functionality. You donâ€™t need to meet color contrast requirements for logos or incidental graphic elements."]ðŸ”š

This produces the basis for the perceptual curve. The lightest color can be thought of as one extreme of the curve, and the darkest can be thought of as the opposite extreme. The necessary contrast between textual elements and their backgrounds can be achieved by taking colors from the extremes of the curve.

Here's an example:

âœ³=(let [plot-edn
      {:width 300 :height 200
       :title "Contrast Ratios Between Colors"
       :data {:values [{"color" 0 "ratio" 4.5} {"color" 1 "ratio" 3}
                       {"color" 2 "ratio" 2.5} {"color" 3 "ratio" 2.0}
                       {"color" 4 "ratio" 1.5} {"color" 5 "ratio" 1.0}
                       {"color" 6 "ratio" 0.5} {"color" 7 "ratio" 0.0}]}
       :layer [{:mark {:type :rule :color "gray"}
                :encoding {:y {:datum 3.0 :type :quantitative}}}
               {:mark {:type :bar
                       :color "black"}
                :encoding {:x {:field "color" :type :ordinal}
                           :y {:field "ratio" :type :quantitative}}}]}]
    (-> plot-edn
        json/write-str
        darkstar/vega-lite-spec->svg))  ðŸ”š

This is a pretty basic curve; others are possible. What's important to note is that it sets the minimum bounds: any textual element needs to have a contrast ratio of at least 3 when compared with the darkest or lightest color.

âœ³=[:h2 "Measuring constrast between colors"]ðŸ”š

The easiest way to get started is just to use an eyedropper to manually pick out some colors and find the contrast ratios between them.
âœ³(def carpente-manual-colors ["#332523" "#ffc81c" "#7e2322" "#ca3169" "#cb342f" "#727a30" "#e46c2d" "#f4f0eb" "#f5f1ec" ])ðŸ”š

âœ³=(apply conj [:div {:style (garden/style {:display "flex" })}]
(for [color carpente-manual-colors]
[:div {:style (garden/style {:flex "0 1 3em" :background-color color :height "2em"})}]))ðŸ”š


We need two fomulas to measure the visual contrast between two colors. The âœ³=[:a {:href "https://www.accessibility-developer-guide.com/knowledge/colours-and-contrast/how-to-calculate/"} "Accessibility Developer Guide"]ðŸ”š provides an example of how to compare two color using their relative luminance. It links to the W3C, which defines "relative luminance" for the SRGB color space. It can be calculated using any RGB hex code.

âœ³=[:dl [:dt [:b "Relative luminance"]]
   [:dd [:b "L"] " = 0.2126 * R + 0.7152 * G + 0.0722 * B"
    [:dl [:dt [:b "R"]] [:dd "if RsRGB <= 0.03928 then R = RsRGB/12.92 else R = ((RsRGB+0.055)/1.055) ^ 2.4"]
     [:dt [:b "G"]] [:dd "if RsRGB <= 0.03928 then G = GsRGB/12.92 else G = ((GsRGB+0.055)/1.055) ^ 2.4"]
     [:dt [:b "B"]] [:dd "if RsRGB <= 0.03928 then B = BsRGB/12.92 else B = ((BsRGB+0.055)/1.055) ^ 2.4"]]]
 [:dt [:b "Contrast Ratio"]] [:dd [:b "C"] " = (L1 + 0.05) / (L2 + 0.05)"
                         [:dl [:dt "L1"] [:dd "The lighter of the two colors"]
                          [:dt "L2"] [:dd "The darker of the two colors"]]]]ðŸ”š

âœ³=[:h5 "Implementations in Clojure"]ðŸ”š

âœ³+(defn hex->rl [hex-color]
   (let [hex (if #(.startsWith hex-color "#") (subs hex-color 1) hex-color)
          [R G B] (map
                   (fn [hex-chars]
                     (-> (apply str hex-chars)
                         (Integer/parseInt 16)
                         (/ 255.0)
                         (#(if (<= % 0.03928) (/ % 12.92)
                               (Math/pow (/ (+ % 0.055) 1.055) 2.4)))))
                   (partition 2 hex))]
     (+ (* 0.2126 R) (* 0.7152 G) (* 0.0722 B))))ðŸ”š

âœ³+(defn rls->cr [colors]
   (let [L1 (apply max colors)
         L2 (apply min colors)]
     (/ (+ L1 0.05) (+ L2 0.05))))ðŸ”š



For a "light theme" the basis color for defining contrast ratios would be the off-white color of âœ³=(let [c (last carpente-manual-colors)] [:span c [:span {:style (garden/style {:color c} )} "â—¤"]])ðŸ”š, whereas for a "dark theme" it would be the near-black color of âœ³=(let [c (first carpente-manual-colors)] [:span c [:span {:style (garden/style {:color c} )} "â—¤"]])ðŸ”š. The contrast ratio of those colors is:

âœ³+=(rls->cr [(hex->rl (last carpente-manual-colors))
              (hex->rl (first carpente-manual-colors)) ])ðŸ”š


Returning to the plot above with those demo colors, we can recolor it so that the bars visually depict the contrast ratios instead of measuring them in a purely quantitative manner, and we can do so with actual example colors instead of abstractly defined ratios.

âœ³(defn plot-edn->svg [p]
   (-> p json/write-str darkstar/vega-lite-spec->svg))ðŸ”š

âœ³=(let [base-color (last carpente-manual-colors)
        contrasts
        (->> carpente-manual-colors
             butlast
             (map (fn [c] {:color c
                           :contrast (rls->cr [(hex->rl base-color)
                                               (hex->rl c)])}))
             (into []))]
  (plot-edn->svg
   {:width 400 :height 300
    :data {:values contrasts}
    :layer [{:mark :rule
             :data {:values [{:contrast 3.0} {:contrast 4.5}]}
             :encoding {:y {:field :contrast :type :quantitative}}}
            {:mark :bar
             :encoding {:x {:field :color :type :nominal}
                        :y {:field :contrast :type :quantitative}
                        :color {:field :color :type :nominal :scale nil}}}]})
    )ðŸ”š

âœ³=[:h2 "Measuring color density within an image"]ðŸ”š

To contextualize the color space of an image, histograms can be a useful tool; it is useful to see the space the optimization will run in.

The image will be represented as a tensor using the capabilities of âœ³=[:code "dtype-next"]ðŸ”š; a 2d image in the RGB colorspace is a 3-dimensional tensor [X, Y, RGB].

âœ³(def carpente-img
  (-> example-images
      first
      :img/url
      io/input-stream
      dtype-img/load)) ðŸ”š

âœ³(def carpente-tens
  (dtype-img/as-ubyte-tensor carpente-img)) ðŸ”š

âœ³=[:code (str (:shape (.dimensions carpente-tens)))]ðŸ”š

The conversion from RGB to HSV needs to be mapped over the X and Y dimensions; the RGB (or Z) dimension for each pixel value is modified as a group, as the conversion to HSV requires all 3 colors.

âœ³(def carptente-hsv-tens (colors/rgb-img->hsv carpente-tens)) ðŸ”š

âœ³(defn img->color-hist [img])ðŸ”š

âœ³=[:h4 "Ideas"]ðŸ”š
We can bin the colors by relative luminance and then compute pairwise contrast ratios, or get the most common colors for a given RL threshold, or any number of other data-driven ways of slicing up the image. "Clamping" the colors to the histogram bins makes the visualization process a bit more robust to small variations in color.

âœ³=[:h2 "Measuring the representativeness of a color"]ðŸ”š

âœ³=[:h2 "Defining the objective function"]ðŸ”š

I will need to optimize over both of these constraints simultaneously.
