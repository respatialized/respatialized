âœ³ (ns respatialized.writing.typesetting-sexprs
  (:require [garden.core :as garden :refer [style css]]
            [garden.selectors :as select]
            [site.fabricate.prototype.page :as page]
            [respatialized.css :as site-css])
  ) ðŸ”š
  

âœ³(def metadata {:title "Typesetting S-Expressions with CSS"
               :page-style (css
                            [:article [:ul [:li {:grid-column "1 / span 4"}]]]
                            [:.keyword {:color (site-css/oklch-hex-conversions "ochre")}]
                            [:.grid-aligned-map
                             #_[:.whitespace :.comma 
                                :.open-brace :.close-brace {:display "none"}]
                             [(select/nth-child 2) {:grid-column-start 1}]
                             {:display "grid"
                              :font-family "'Chivo Mono', monospace"
                              :font-variant-ligatures "none"
                              :grid-template-columns "repeat(2,minmax(3px, 1fr))"}
                             ]
                            [:.map-flex
                             {:display "flex"
                              :grid-column "1 / 6"
                              :column-gap "max(4px, 0.25em)"
                              :flex-direction "row"
                              :flex-wrap "wrap"
                              ;;:min-width 0
                              :font-family "'Chivo Mono', monospace"
                              :justify-content "start"
                              :font-variant-ligatures "none"}
                             [:.whitespace {:display "none"
                                            :width 0
                                            :column-gap 0}]
                             [:.comma {:column-gap 0}]]
                            )}) ðŸ”š
                            

âœ³= [:h1 (:title metadata)] ðŸ”š

âœ³=[:strong "Problem statement"] ðŸ”š CSS is a very powerful library for styling and laying out page elements, but almost no extant HTML-based syntax highlighting tools for Clojure take full advantage of it. Instead, most people opt for code-based syntax highlighters (or no syntax highlighting at all).


âœ³=[:strong "Assumptions"] ðŸ”š
âœ³=[:ul {:style (style {:grid-column "1 / span 4"})}
 [:li "The structural and sequential nature of Lisp expressions means they more readily lend themselves to CSS selectors than the code of other programming languages"]
 [:li "Server side rendering with rewrite-clj means that all of the relevant syntax and semantics of Clojure code can be preserved via appropriate HTML classes"]
 ] ðŸ”š
 
âœ³=[:strong "Goals"] ðŸ”š
I believe that Clojure source code deserves beautiful syntax highlighting that leverages the full power of modern CSS.


âœ³=[:strong "Prior art"] ðŸ”š

Several bloggers in the Haskell community do a very good job of presenting source code as a coherent part of an overall document. âœ³=[:a {:href "https://chrisdone.com/posts/fast-haskell-c-parsing-xml/"} "Chris Done"] ðŸ”š and  âœ³=[:a {:href "https://wickstrom.tech/"} "Oskar WickstrÃ¶m"] ðŸ”š both have excellent blogs.

WickstrÃ¶m's  âœ³=[:a {:href "https://wickstrom.tech/programming/2021/05/03/specifying-state-machines-with-temporal-logic.html"} "blending of diagrams, code, and prose"] ðŸ”š to illustrate technical concepts is one of the points of inspiration for Fabricate, the static website generator I wrote and used to generate these examples.

The multimethod-based generation of Hiccup elements from rewrite-clj nodes was adapted and extended from Michiel Borkent's âœ³=[:a {:href "https://github.com/borkdude/quickblog"} "quickblog"] ðŸ”š; he helpfully describes the approach in  âœ³=[:a {:href "https://blog.michielborkent.nl/writing-clojure-highlighter.html"} "Writing a Clojure highlighter from scratch."] ðŸ”š I believe that only tools that can leverage the full structure of Clojure's source code are appropriate to the task of generating effective documentation of Clojure code.

This page will have notes on several experiments in using CSS layout features for the display of Clojure expressions. Readers are strongly encouraged to use their web browser's inspector mode to see the hierarchy of elements and CSS rules used to generate these layouts.

âœ³= [:h2 "aligning map elements to CSS grid"] ðŸ”š

This page already uses CSS grid for its layout, so one starting point would be to just align the elements representing the map contents to the main grid.

âœ³=
(update-in
 (page/expr->hiccup
  {:a/key "value"
   :attributeName "stroke-dashoffset"
   :values "0;2000"
   :some/key "some other value"
   :additive "sum"
   :dur "360s"
   :repeatCount "indefinite"}
  ) [1 :class]  #(str % " grid-aligned-map"))
ðŸ”š

Problems with this approach:
âœ³= [:ul
  [:li "whitespace and commas are treated as grid elements unless there's a way to get the grid to ignore them; the " [:a {:href "https://stackoverflow.com/a/32380418"} [:code "nth-child"]" selector will not skip elements set to " [:code "display: none;"]]]
  [:li "lack of support for CSS subgrid means that nested maps will be difficult to align"]]
ðŸ”š

âœ³= [:h2 "laying map elements out with flexbox"] ðŸ”š

âœ³=

(update-in
 (page/expr->hiccup
  {:a/key "value"
   :attributeName "stroke-dashoffset"
   :values "0;2000"
   :some/key "some other value"
   :additive "sum"
   :dur "360s"
   :repeatCount "indefinite"}
  ) [1 :class]  #(str % " map-flex"))
ðŸ”š

It appears to be easier to fully hide insignificant elements with Flexbox than grid, but it may be harder to align keys to a left baseline. Inserting line breaks for each key may also be more difficult than with grid.

âœ³= [:h2 "A manually constructed example of grid layout for a map"] ðŸ”š

This example uses nested flexboxes create an aligned container for the map contents and manually inserted âœ³=[:a {:href "https://graffino.com/til/D0xjf7VIGi-how-to-force-a-flexbox-item-to-a-new-row"} "zero-height elements"] ðŸ”š before each new map key to force line breaks within the flexbox at the appropriate places.

âœ³=
[:span {:class "language-clojure map"
        :style (style {:grid-column "1 / span 4"
                       :display "flex"
                       :font-family "'Chivo Mono', monospace"
                       :flex-wrap "wrap"
                       :flex-direction "row"})}
 [:span {:class "language-clojure open-brace"} "{"]
 [:span {:class "language-clojure map-contents"
         :style (style {:display "flex"
                        :width "50ch"
                        :flex-wrap "wrap"})}
  [:span {:class "language-clojure keyword"} ":a/key"]
  [:span {:class "language-clojure whitespace"} " "]
  [:span {:class "language-clojure string"} "&quot;value&quot;"]
  [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
  [:span {:class "language-clojure whitespace"} " "]
  [:span {:style (style {:flex-basis "100%" :height 0})}]
  [:span {:class "language-clojure keyword"} ":attributeName"]
  [:span {:class "language-clojure whitespace"} " "]
  [:span {:class "language-clojure string"} "&quot;stroke-dashoffset&quot;"]
  [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
  [:span {:class "language-clojure whitespace"} " "]
  [:span {:style (style {:flex-basis "100%" :height 0})}]
  [:span {:class "language-clojure keyword"} ":values"]
  [:span {:class "language-clojure whitespace"} " "]
  [:span {:class "language-clojure string"} "&quot;0;2000&quot;"]
  [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
  [:span {:class "language-clojure whitespace"} " "]
  [:span {:style (style {:flex-basis "100%" :height 0})}]
  [:span {:class "language-clojure keyword"} ":some/key"]
  [:span {:class "language-clojure whitespace"} " "]
  [:span {:class "language-clojure string"} "&quot;some other value&quot;"]
  [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
  [:span {:class "language-clojure whitespace"} " "]
  [:span {:style (style {:flex-basis "100%" :height 0})}]
  [:span {:class "language-clojure keyword"} ":additive"]
  [:span {:class "language-clojure whitespace"} " "]
  [:span {:class "language-clojure string"} "&quot;sum&quot;"]
  [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
  [:span {:class "language-clojure whitespace"} " "]
  [:span {:style (style {:flex-basis "100%" :height 0})}]
  [:span {:class "language-clojure keyword"} ":dur"]
  [:span {:class "language-clojure whitespace"} " "]
  [:span {:class "language-clojure string"} "&quot;360s&quot;"]
  [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
  [:span {:class "language-clojure whitespace"} " "]
  [:span {:style (style {:flex-basis "100%" :height 0})}]
  [:span {:class "language-clojure keyword"} ":repeatCount"]
  [:span {:class "language-clojure whitespace"} " "]
  [:span {:class "language-clojure string"} "&quot;indefinite&quot;"]]
 [:span {:class "language-clojure close-brace"
         :style (style {:align-self "end"})} "}"]]
ðŸ”š

âœ³=[:strong "Problems:"] ðŸ”š the flex-basis 100% elements prevents flex-shrink from sizing the map down to an appropriate size. It similarly will also cause problems with flex-wrap: wrap on the top-level flexbox unless the nested flexbox for the map elements has a manually constrained size (this example does).

But overall this has the right look. The keys are aligned, the text is still wholly copyable into a plaintext buffer, and it flows nicely with the typographic baseline established by the main text.

The challenge is generating this type of layout programatically from rewrite-clj nodes, and doing so in a way that doesn't generate absurd layouts when displaying potentially nested maps.

âœ³= [:h2 "Another example with manually &ltspan&gted key/value pairs"] ðŸ”š

Because the elements are being generated by rewrite-clj, one possible option would be to process them in a way that groups together key/value pairs. Here is a manual example that shows taking advantage of Flexbox layout to distribute these pairs in the space provided by the map contents element.

âœ³=
[:pre {:style (style {:grid-column "1 / span 4"
                      :margin-top "0em"})}
 [:span {:class "language-clojure map"
         :style (style {
                        :display "flex"
                        ;;:flex-wrap "wrap"
                        :flex-direction "row"})}
  [:span {:class "language-clojure open-brace"} "{"]
  [:span {:class "language-clojure map-contents"
          :style (style {:display "flex"
                         :max-width "60ch"
                         :column-gap "max(4px, 0.5em)"
                         :justify-content "flex-start"
                         :flex-wrap "wrap"})}
   [:span {:class "language-clojure keyval"}
    [:span {:class "language-clojure keyword"} ":a/key"]
    [:span {:class "language-clojure whitespace"} " "]
    [:span {:class "language-clojure string"} "&quot;value&quot;"]
    [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
    [:span {:class "language-clojure whitespace"} " "]]
   [:span {:clas "language-clojure keyval"}
    [:span {:class "language-clojure keyword"} ":attributeName"]
    [:span {:class "language-clojure whitespace"} " "]
    [:span {:class "language-clojure string"} "&quot;stroke-dashoffset&quot;"]
    [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
    [:span {:class "language-clojure whitespace"} " "]]
   [:span {:class "language-clojure keyval"}
    [:span {:class "language-clojure keyword"} ":values"]
    [:span {:class "language-clojure whitespace"} " "]
    [:span {:class "language-clojure string"} "&quot;0;2000&quot;"]
    [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
    [:span {:class "language-clojure whitespace"} " "]]
   [:span {:class "language-clojure keyval"}
    [:span {:class "language-clojure keyword"} ":some/key"]
    [:span {:class "language-clojure whitespace"} " "]
    [:span {:class "language-clojure string"} "&quot;some other value&quot;"]
    [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
    [:span {:class "language-clojure whitespace"} " "]]
   [:span {:class "language-clojure keyval"}
    [:span {:class "language-clojure keyword"} ":additive"]
    [:span {:class "language-clojure whitespace"} " "]
    [:span {:class "language-clojure string"} "&quot;sum&quot;"]
    [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
    [:span {:class "language-clojure whitespace"} " "]]
   [:span {:class "language-clojure keyval"}
    [:span {:class "language-clojure keyword"} ":dur"]
    [:span {:class "language-clojure whitespace"} " "]
    [:span {:class "language-clojure string"} "&quot;360s&quot;"]
    [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
    [:span {:class "language-clojure whitespace"} " "]]
   [:span {:class "language-clojure keyval"}
    [:span {:class "language-clojure keyword"} ":repeatCount"]
    [:span {:class "language-clojure whitespace"} " "]
    [:span {:class "language-clojure string"} "&quot;indefinite&quot;"]]]
  [:span {:class "language-clojure close-brace"
          :style (style {:align-self "end"})} "}"]]]
ðŸ”š

This also looks appealing, ensuring a decent visual separation between the map elements while preventing keys and values from being split across a linebreak, which helps with visual comprehension of the map. Given that it does not require inserting elements or pseudo-elements that emulate a line break, it may be both much more robust and easier to implement than any solution that involves the insertion of invisible elements to manipulate flexbox rules.

âœ³= [:h2 "A function definition"] ðŸ”š
A function definition presents more complex layout challenges than arranging key/value pairs in a map. It may require more preprocessing on the server side to separate into the basic semantic elments needed for effective display.

âœ³=
[:pre {:style (style {:grid-column "1 / span 4"})}
 (page/expr->hiccup
  
  '(defn de-jong
     "Returns A Peter de Jong attractor function.

Use with clojure.core/iterate."
     {:added "2023-06-11"}
     [^Double a ^Double b ^Double c ^Double d]
     (fn [[^Double x ^Double y]]
       [(- (Math/sin (* a y)) (Math/cos (* b x)))
        (- (Math/sin (* c x)) (Math/cos (* d y)))]))
  
  )] ðŸ”š