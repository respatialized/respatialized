âœ³ (ns respatialized.writing.typesetting-sexprs
  (:require [garden.core :as garden :refer [style css]]
            [garden.selectors :as select]
            [site.fabricate.prototype.page :as page]
            [respatialized.css :as site-css])
  ) ðŸ”š
  

âœ³(def metadata {:title "typesetting s-expressions with CSS"
               :page-style (css
                            [:.keyword {:color (site-css/oklch-hex-conversions "ochre")}]
                            [:.grid-aligned-map
                             #_[:.whitespace :.comma 
                                :.open-brace :.close-brace {:display "none"}]
                             [(select/nth-child 2) {:grid-column-start 1}]
                             {:display "grid"
                              :font-family "'Chivo Mono', monospace"
                              :font-variant-ligatures "none"
                              :grid-template-columns "repeat(2,minmax(3px, 1fr))"}
                             ]
                            [:.map-flex
                             {:display "flex"
                              :grid-column "1 / 6"
                              :column-gap "max(4px, 0.25em)"
                              :flex-direction "row"
                              :flex-wrap "wrap"
                              ;;:min-width 0
                              :font-family "'Chivo Mono', monospace"
                              :justify-content "start"
                              :font-variant-ligatures "none"}
                             [:.whitespace {:display "none"
                                            :width 0
                                            :column-gap 0}]
                             [:.comma {:column-gap 0}]
                             ]
                            )}) ðŸ”š
                            

âœ³= [:h1 (:title metadata)] ðŸ”š

âœ³=[:strong "Problem statement"] ðŸ”š CSS is a very powerful library for styling and laying out page elements, but almost no extant HTML-based syntax highlighting tools for Clojure take full advantage of it. Instead, most people opt for code-based syntax highlighters (or no syntax highlighting at all).


âœ³=[:strong "Assumptions"] ðŸ”š
âœ³=[:ul
 [:li "The structural and sequential nature of Lisp expressions means they more readily lend themselves to CSS selectors than the code of other programming languages"]
 [:li "Server side rendering with rewrite-clj means that all of the relevant syntax and semantics of Clojure code can be preserved via appropriate HTML classes"]
 ] ðŸ”š
 
âœ³=[:strong "Goals"] ðŸ”š
I believe that Clojure source code deserves beautiful syntax highlighting that leverages the full power of modern CSS.

âœ³= [:h2 "aligning map elements to CSS grid"] ðŸ”š
âœ³=
(update-in
 (page/expr->hiccup
  {:a/key "value"
   :attributeName "stroke-dashoffset"
   :values "0;2000"
   :some/key "some other value"
   :additive "sum"
   :dur "360s"
   :repeatCount "indefinite"}
  ) [1 :class]  #(str % " grid-aligned-map"))
ðŸ”š

Problems with this approach:
âœ³= [:ul
  [:li "whitespace and commas are treated as grid elements unless there's a way to get the grid to ignore them; the " [:a {:href "https://stackoverflow.com/a/32380418"} [:code "nth-child"]" selector will not skip elements set to " [:code "display: none;"]]]
  [:li "lack of support for CSS subgrid means that nested maps will be difficult to align"]]
ðŸ”š

âœ³= [:h2 "laying map elements out with flexbox"] ðŸ”š

âœ³=

(update-in
 (page/expr->hiccup
  {:a/key "value"
   :attributeName "stroke-dashoffset"
   :values "0;2000"
   :some/key "some other value"
   :additive "sum"
   :dur "360s"
   :repeatCount "indefinite"}
  ) [1 :class]  #(str % " map-flex"))
ðŸ”š

It appears to be easier to fully hide insignificant elements with Flexbox than grid, but it may be harder to align keys to a left baseline. Inserting line breaks for each key may also be more difficult than with grid.

âœ³= [:h2 "A manually constructed example of grid layout for a map"] ðŸ”š

This example uses nested flexboxes create an aligned container for the map contents and manually inserted âœ³=[:a {:href "https://graffino.com/til/D0xjf7VIGi-how-to-force-a-flexbox-item-to-a-new-row"} "zero-height elements"] ðŸ”š before each new map key to force line breaks within the flexbox at the appropriate places.

âœ³=
[:pre #_{:style  nil}
 [:span {:class "language-clojure map"
         :style (style {:grid-column "1 / 3"
                        :display "flex"
                        :flex-wrap "wrap"
                        :flex-direction "row"})}
  [:span {:class "language-clojure open-brace"} "{"]
  [:span {:class "language-clojure map-contents"
          :style (style {:display "flex"
                         :width "50ch"
                         :flex-wrap "wrap"})}
   [:span {:class "language-clojure keyword"} ":a/key"]
   [:span {:class "language-clojure whitespace"} " "]
   [:span {:class "language-clojure string"} "&quot;value&quot;"]
   [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
   [:span {:class "language-clojure whitespace"} " "]
   [:span {:style (style {:flex-basis "100%" :height 0})}]
   [:span {:class "language-clojure keyword"} ":attributeName"]
   [:span {:class "language-clojure whitespace"} " "]
   [:span {:class "language-clojure string"} "&quot;stroke-dashoffset&quot;"]
   [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
   [:span {:class "language-clojure whitespace"} " "]
   [:span {:style (style {:flex-basis "100%" :height 0})}]
   [:span {:class "language-clojure keyword"} ":values"]
   [:span {:class "language-clojure whitespace"} " "]
   [:span {:class "language-clojure string"} "&quot;0;2000&quot;"]
   [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
   [:span {:class "language-clojure whitespace"} " "]
   [:span {:style (style {:flex-basis "100%" :height 0})}]
   [:span {:class "language-clojure keyword"} ":some/key"]
   [:span {:class "language-clojure whitespace"} " "]
   [:span {:class "language-clojure string"} "&quot;some other value&quot;"]
   [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
   [:span {:class "language-clojure whitespace"} " "]
   [:span {:style (style {:flex-basis "100%" :height 0})}]
   [:span {:class "language-clojure keyword"} ":additive"]
   [:span {:class "language-clojure whitespace"} " "]
   [:span {:class "language-clojure string"} "&quot;sum&quot;"]
   [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
   [:span {:class "language-clojure whitespace"} " "]
   [:span {:style (style {:flex-basis "100%" :height 0})}]
   [:span {:class "language-clojure keyword"} ":dur"]
   [:span {:class "language-clojure whitespace"} " "]
   [:span {:class "language-clojure string"} "&quot;360s&quot;"]
   [:span {:class "language-clojure comma"} [:span {:class "language-clojure comma"} ","]]
   [:span {:class "language-clojure whitespace"} " "]
   [:span {:style (style {:flex-basis "100%" :height 0})}]
   [:span {:class "language-clojure keyword"} ":repeatCount"]
   [:span {:class "language-clojure whitespace"} " "]
   [:span {:class "language-clojure string"} "&quot;indefinite&quot;"]]
  [:span {:class "language-clojure close-brace"
          :style (style {:align-self "end"})} "}"]]]
ðŸ”š

âœ³=[:strong "Problems:"] ðŸ”š the flex-basis 100% elements prevents flex-shrink from sizing the map down to an appropriate size. It similarly will also cause problems with flex-wrap: wrap on the top-level flexbox unless the nested flexbox for the map elements has a manually constrained size (this example does).

But overall this has the right look. The keys are aligned, the text is still wholly copyable into a plaintext buffer, and it flows nicely with the typographic baseline established by the main text.

The challenge is generating this type of layout programatically from rewrite-clj nodes, and doing so in a way that doesn't generate absurd layouts when displaying potentially nested maps.