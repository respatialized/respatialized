âœ³(ns respatialized.sketches.extruder
 (:require [respatialized.render :refer :all]
           [site.fabricate.prototype.page :refer :all]
           [respatialized.holotype :as holotype]
           [malli.core :as m]
           [fastmath.random :as r]))ğŸ”š

âœ³ (def metadata
    {:title "extruder"
     :page-style  respatialized.writing.design.database/page-css})ğŸ”š

âœ³= [:header [:h1 (:title metadata)]
[:h4 "2021/08/08"]]ğŸ”š

This post explores the idea of an extruder to create generative designs.

The simplest way to explore this concept in two dimensions is to implement extruded segments as a kind of constrained Brownian motion. The basic constraints:
âœ³=[:ul [:li "Segments have a fixed length"]
       [:li "Segments may not overlap or intersect with other segments"]]ğŸ”š
If a segment "hits" another, it can adjust its heading to continue. If it cannot continue without hitting another segment, then it stops.

Before it is completed, a segment must hold on to three pieces of state:
âœ³=[:ul [:li "The positions of other segments"]
[:li "Its current heading"]
[:li "Its remaining 'fuel' "]]ğŸ”š

âœ³(def segment [:+ [:schema [:cat :int :int]]])ğŸ”š
âœ³(def drawing-segment
  [:map
   [:segment segment]
   [:heading [:fn fn?]]
   [:fuel :int]])ğŸ”š


âœ³=  [:h1 "Lambda, the ultimate GOTO"]ğŸ”š

Conceptually, a heading is just a function that takes a current position and returns the next position. Change this function, and you change the heading.

Alternatively, it could be a function that takes a position and heading and returns a position and heading.

âœ³(assert (m/validate segment [[1 2] [1 3]]))ğŸ”š

âœ³(assert (m/validate drawing-segment
                    {:segment [[1 2] [1 3]]
                     :heading (fn [[x y]] [(inc x) y])
                     :fuel 20}))ğŸ”š


âœ³ (defn east [[x y]] [(inc x) y])  ğŸ”š
âœ³ (defn west [[x y]] [(dec x) y])  ğŸ”š
âœ³ (defn north [[x y]] [ x (dec y)])  ğŸ”š
âœ³ (defn south [[x y]] [ x (inc y)])  ğŸ”š

âœ³(def clockwise-cardinal-headings
  {north east
   east south
   south west
   west north})ğŸ”š

âœ³ (defn iterate-map [v m]
  (if (m v)
    (take (inc (count m)) (iterate m v))
    (list nil))) ğŸ”š


âœ³(defn extend-segment
   {:malli/schema
    [:=> [:cat drawing-segment [:* [:schema segment]]]
     [:or segment drawing-segment]]}
   [current-segment other-segments]
  (if (<= (:fuel current-segment) 0) (:segment current-segment)
      (let [current-position (peek (:segment current-segment))
            all-points
            (apply concat (conj other-segments (:segment current-segment)))
            ;; lazily compute possible next directions + points
            possible-next-headings
            (iterate-map (:heading current-segment) clockwise-cardinal-headings)
            next (->> possible-next-headings
                      (map (fn [h] [h (h current-position)]))
                      (filter (fn [[h next-pos]] (not-any? #(= % next-pos)
                                                           all-points)))
                      ;; take the first one that works
                      first)]
        (if next (-> current-segment
                     (update :fuel dec)
                     (update :segment conj (last next))
                     (assoc :heading (first next)))
            (:segment current-segment))


        )))ğŸ”š

âœ³(defn extrude-segment [current-segment other-segments]
  (loop [s current-segment]
    (let [next (extend-segment s other-segments)]
      (if (m/validate segment next) (conj other-segments next)
          (recur next)))))ğŸ”š

âœ³(defn segment->svg [segment svg-attrs]
  [:polyline
   (merge
    {:points (clojure.string/join " " (map #(clojure.string/join "," %) segment))}
    svg-attrs)])ğŸ”š


âœ³= [:header [:h1 "Extrusion 1"]
[:h4 "2021/08/29"]]ğŸ”š

This is a visual test to ensure the reducing functions that yield extruded segments work properly. I haven't yet developed a function to define the interaction between two segments in the way that matches my initial sketches, but reducing over a sequential collection of points is a powerful and general way of building up the segments, and defining the heading as a function is a clever way of anticipating and accomodating future changes.

âœ³=
(let [starting-segments
      (map (fn [sx sy sh f]
             {:segment [[sx sy]]
              :heading sh
              :fuel f})
           (range 20 480 6)
           (range 20 480 6)
           (cycle [north west ])
           (cycle [180 90 60 120 150 30 210])
           )
      container [:svg {:width 500 :height 500
                       :viewBox "0 0 500 500"}]
      extruded-segments
      (reduce (fn [sgmts next-start]
                (extrude-segment next-start sgmts))
              []
              starting-segments)]
  (apply conj container (map #(segment->svg % {:stroke "#f1d1bd" :stroke-width 2}) extruded-segments)))ğŸ”š
