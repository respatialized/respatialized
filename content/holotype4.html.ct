<%(ns respatialized.holotype4
    (:require [clojure2d.core :as clj2d]
              [respatialized.structure.fractals :as fractals]
              [respatialized.holotype :as holotype]
              [malli.core :as m]
              [garden.core :as garden]
              [garden.stylesheet :as style]
              [clojure.java.io :as io]
              [tech.v3.dataset :as ds]
              [tech.v3.tensor :as tensor]
              [tech.v3.datatype :as dtype]
              [tech.v3.datatype.functional :as dtype-fn]
              [tech.v3.libs.buffered-image :as buf-img]
              [criterium.core :as criterium])
    (:import [tech.v3.tensor DirectTensor]))

%>


<%(def page-style
  (garden/css
   (style/at-import "https://fonts.googleapis.com/css2?family=Anonymous+Pro&family=Share+Tech+Mono&display=swap")
   [:body {:font-family "'Share Tech Mono'"
       :background-color "#0F1C48"
       :color "#DDD"}]
       [:a {:color "#2211EE"}]
       [:header {:font-family "'Share Tech Mono'"
       :border-bottom "2px solid"
       :border-bottom-color "#DDD"
       :letter-spacing "-0.12rem"
       :color "#DDD"
       :text-transform "uppercase"}]
       [:article {:color "#DDD"}]))%>

<% (def metadata {:title "HOLOTYPE//4"
                  :page-style page-style}) %>

<%= (header (:title metadata)) %>
<%= (header {:level :h4} "Computational texture generation with attractors + clustering") %>

<%=(header {:level :h2} "synthetic topographies / 1")%>

generate a density map using Clifford attractors and draw contour lines around the points using the density as a height estimator.

general strategy: sort the resulting values into layers based on density and draw contours around each of them.

<% (def empty-img (buf-img/new-image 1100 650 :int-rgb)) %>
<% (def img-tensor (buf-img/as-ubyte-tensor empty-img)) %>

<% (def canvas (clj2d/with-canvas->
                 (clj2d/canvas 900 1400)
                 (clj2d/set-background (clojure2d.color/to-RGB "#C0B9AA"))
                 )) %>

<%
;; let's get some pixels on the page, shall we?
(defn save-insert! [img fpath]
  (do
    (buf-img/save! img fpath)
    (let [img-url (-> fpath
                      io/file
                      .getName
                      (#(str "/media/" %)))]
      [:figure
       [:img {:src img-url}]]))) %>

<% (defn tensor-de-jong [^Double a ^Double b ^Double c ^Double d]
  ;; this probably isn't the best implementation
  ;; but it's a starting point
  (fn tensor-de-jong-iter [[^DirectTensor xs ^DirectTensor ys]]
    [(dtype/clone (dtype-fn/- (dtype-fn/sin (dtype-fn/* a ys))
                        (dtype-fn/cos (dtype-fn/* b xs))))
     (dtype/clone (dtype-fn/- (dtype-fn/sin (dtype-fn/* c xs))
                              (dtype-fn/cos (dtype-fn/* d ys))))])) %>

<% (def starting-pts-linear
  [(fastmath.core/slice-range 0.1 0.25 5)
   (fastmath.core/slice-range 0.3 0.33 5)]) %>


<% (def starting-pts-de-jong
  (let [dejong-res (take 5 (iterate fractals/dejong1 [0.5 0.5]))]
    [(dtype/make-container (map first dejong-res))
     (dtype/make-container (map last dejong-res))])) %>



<%

(defn iter-img
  ([starting-img starting-pts attractor rasterizer! iterations]
   (loop [n iterations
          current starting-pts]
     (if (= n 0) current
         (let [next (attractor current)]
           (do (rasterizer! next starting-img))
           (recur
            (- n 1)
            next)))))
  ([starting-img starting-pts attractor rasterizer!]
   (fn [iterations] (iter-img starting-img starting-pts attractor rasterizer! iterations))))

%>

<% (defn iter-cnvs
     ([cnvs pts attractor rasterizer iterations]
      (loop [n iterations
             current pts
             canvas cnvs]
        (println "iteration" (- iterations n)  "input size" (count (first current)))
        (if (= n 0) canvas
            (let [next (time (attractor current))
                  next-cnvs (time (rasterizer next canvas))]
              (recur
               (- n 1)
               next
               next-cnvs)))))
  ([cnvs pts attractor rasterizer]
   (fn [iterations]
     (iter-cnvs cnvs pts attractor rasterizer)))) %>

<%
(defn coords+tensor!
  ([^DirectTensor xs ^DirectTensor ys ^DirectTensor t magnitude]
   (doseq [x xs y ys]
     (.ndWriteLong t x y 0 magnitude)
     (.ndWriteLong t x y 1 magnitude)
     (.ndWriteLong t x y 2 magnitude))
   t))

%>

<% (defn paint-canvas [^DirectTensor xs ^DirectTensor ys canvas]
  (println "timing type conv:")
  (let [xarray (time (dtype/->double-array xs))
        yarray (time (dtype/->double-array ys))]
       (clj2d/with-canvas-> canvas
         (clj2d/set-stroke 0)
         (clj2d/set-color (clojure2d.color/to-RGB "#CD4C30"))
         (#(do
             (doseq [x xarray y yarray]
               (clj2d/ellipse % (Math/floor x) (Math/floor y) 2 2))
             %))))) %>



<%(defn normalize [^DirectTensor t ^Double old-extent  ^Long new-extent ^Long offset]
  (dtype-fn/+ (dtype-fn/* (dtype-fn// t old-extent) new-extent) offset)) %>

<%

(defn rasterize-xys
  ([[^DirectTensor xs ^DirectTensor ys] ^DirectTensor tens ^Long magnitude]
   (let [two-pi (* Math/PI 2)
         [width height] (dtype/shape tens)
         x-center (/ width 2)
         y-center (/ height 2)
         xs-normed (normalize xs two-pi width x-center)
         #_(-> xs
               (dtype-fn// two-pi)
               (dtype-fn/* width)
               (dtype-fn/round)
               (dtype-fn/+ x-center))
         ys-normed (normalize ys two-pi height y-center)
         #_(-> ys
             (dtype-fn// two-pi)
             (dtype-fn/* height)
             (dtype-fn/round)
             (dtype-fn/+ y-center))
         vals [magnitude magnitude magnitude]]

     (coords+tensor! xs-normed ys-normed tens magnitude)))

  ([^Long magnitude] (fn [[^DirectTensor xs ^DirectTensor ys] ^DirectTensor tens] (rasterize-xys [xs ys] tens magnitude))))

%>

<% (defn canvas-xys
  ([[xs ys] cnvs]
   (println "time for xnorm,ynorm,canvas update")
   (let [two-pi (* Math/PI 2)
         width (:w cnvs)
         height (:h cnvs)
         x-center (/ width 2)
         y-center (/ height 2)
         xs-normed (time (normalize xs two-pi width x-center))
         ys-normed (time (normalize ys two-pi height y-center))]

     (paint-canvas xs-normed ys-normed cnvs)))
  ([] (fn [[xs ys] cnvs] (canvas-xys [xs ys] cnvs)))) %>

<% (def dejong-iter-img (iter-cnvs
                         canvas
                         starting-pts-de-jong
                         (tensor-de-jong 0.834 1.902 1.6 2.4)
                         (canvas-xys)
                         20000
                         ))  %>

<%= (holotype/canvas->hiccup! dejong-iter-img  "./public/media/holotype4-1.png" "holotype4-1") %>

<%= (header {:level :h5} "Other ideas") %>

Tensor attractors - what if the dynamical system was a vector instead of a point?

Parameter evolution - what if the constant parameters iterated through a space along with the point?

Displacement evolution - what if the "center point" was doing a random walk or otherwise evolving with the system?

Displacement maps - what if the results of an attractor's iterations were transformed by doing tensor operations with a displacement map?

Attractors in color space - what would a 3d attractor moving through the HSB color space look like?
