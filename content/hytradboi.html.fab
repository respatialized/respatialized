âœ³(ns respatialized.writing.hytradboi
  (:require [garden.core :refer [css style]]
            [respatialized.archive :as archive]
            [asami.core :as d]
            [hiccup2.core :refer [html]]
            [hiccup.util :refer [escape-html]]
            [site.fabricate.prototype.read.grammar :refer [delimiters]]))ðŸ”š

âœ³(def metadata {:title "Outline for 'Have You Tried Rubbing A Database On It?'" :page-style (css [:article {:hyphens "auto"}]) })ðŸ”š

âœ³=[:h3 (:title metadata)]ðŸ”š
âœ³=[:aside [:em "For the purposes of my application to the conference, this page should be considered the draft script to what I will present, not the visual component of presentation itself. I won't be presenting a wall of text for the video. I will have my REPL running as I record and flip to it as necessary to demonstrate my point."]]ðŸ”š
âœ³//[:section {:class "point"}

âœ³=[:h4 "What this talk is"]ðŸ”š


âœ³//[:div {:style (style {:display "grid" :grid-template-columns "1fr 1fr" :grid-gap "2em"})}
âœ³//[:div
This talk is a page generated by fabricate, a static website generator I wrote in Clojure. Fabricate, rather than using traditional markup syntax, lets you use emoji to embed the results of Clojure expressions into plaintext. The talk describes Fabricate's history and how I extended it to incorporate a database as a creative tool. We will modify the page later to see how it works.
]//ðŸ”š
âœ³//[:div
An example of fabricate:
âœ³=[:pre [:code "Some text" [:br] (str (first delimiters) "=[:aside \"an inline aside\"]" (last delimiters)) [:br] "More text following."]]ðŸ”š
]//ðŸ”š
]//ðŸ”š
]//ðŸ”š


âœ³//[:section {:class "point"}

âœ³=[:h4 "Excavating some digital writing history"]ðŸ”š
I'd like to locate this talk in the history of digital writing tools. One of my favorite books is âœ³=[:em "Annals of the Former World"]ðŸ”š, a wonderful and idiosyncratic tour through North American geology. The book deftly layers, like sediment, multiple timescales of geological events, the recent human past, and the relatively short journeys McPhee takes with geologists to learn about how the landscape assembled itself.

John McPhee is not a programmer, but computer programs helped him write the book, which won the 1999 Pulitzer Prize for nonfiction. They were called âœ³=[:code "structur"]ðŸ”š  and  âœ³=[:code "alpha"]ðŸ”š, implemented as macros for âœ³=[:a {:href "https://en.wikipedia.org/wiki/XEDIT#KEDIT"} [:code "kedit"]]ðŸ”š, a block editor from 1983, written for McPhee by Howard J. Strauss at Princeton. He describes it in a âœ³=[:a {:href "https://www.newyorker.com/magazine/2013/01/14/structure"} "2013 essay"] ðŸ”š for the New Yorker called "Structure."

âœ³//[:blockquote
Howard, who died in 2005, was the polar opposite of Bill Gatesâ€”in outlook as well as income. Howard thought the computer should be adapted to the individual and not the other way around. One size fits one. The programs he wrote for me were molded like clay to my requirementsâ€”an appealing approach to anything called an editor.

â€¦Used again and again on an ever-concentrating quantity of notes, alpha works like nesting utensils. It sorts the whole business at the outset, and then, as I go along, it sorts chapter material and subchapter material, and it not infrequently arranges the components of a single paragraph. It has completely served many pieces on its own.
]//ðŸ”š

I have little doubt that the complex juxtaposition of ideas and timescales in âœ³=[:em "Annals of the Former World"]ðŸ”š owes a lot to the creative capabilities of those programs, which were inspired by McPhee's earlier notecard-based writing process. I begin this talk with a question and a challenge posed to both myself and to the programmer community: are we making tools as suited to individual expression as this?

]//ðŸ”š


âœ³//[:section {:class "point"}

âœ³=[:h4 "The recent past"]ðŸ”š
 âœ³=[:a {:href "https://docs.racket-lang.org/pollen/"} [:code "Pollen"]]ðŸ”š, a writing and publishing system for Racket, is one example of software that I believe takes that question seriously. Matthew Butterick, a programmer, typographer, and lawyer, built it to overcome the limitations of other digital publishing tools for his excellent book
âœ³=[:a {:href "https://practicaltypography.com"} [:em "Practical Typography."]]ðŸ”š

âœ³=[:blockquote
"At the core of Pollen is an argument:"
[:ol
[:li "Digital books should be the best books weâ€™ve ever had. So far, theyâ€™re not even close."]
[:li "Because digital books are software, an author shouldnâ€™t think of a book as merely data. The book is a program."]
[:li "The way we make digital books better than their predecessors is by exploiting this programmability."]]
]ðŸ”š
Fabricate grew out of me pushing myself further and further to meet the challenge thrown down by Butterick in his introduction. It also uses a variation on Pollen's syntax to blend code and text. An unexpectedly serendipitous connection came through âœ³=[:a {:href "https://github.com/otherjoel/thenotepad"} [:code "thenotepad,"] "Joel Dueck's toolkit around Pollen"]ðŸ”š, which uses a sqlite database to cache posts and save on rendering time. I began to think about other ways a website generator could leverage a database - as a creative and organizational tool rather than as a mere persistence layer. I'm still pulling on the thread that design choice started in my mind, and it has led me here. I have been helped immensely along the way by a plethora of exciting projects in the Clojure community, more than one of which offered me a way out of the pit I had most recently dug myself into.

âœ³=[:aside [:em
"Interestingly, Dueck now uses a " [:a {:href "https://joeldueck.com/wiki?name=Just+a+Fossil+repo"}[:code "Fossil"] " repo"] "for his blog, which gets a shout-out in the conference description."
]]ðŸ”š
]//ðŸ”š

âœ³//[:section {:class "point"}

âœ³=[:h4 "The problem with static website generators"]ðŸ”š
I'll leave aside my arguments against Markdown (ok, here's one: I wanted to do something as simple as put two columns of text next to each other for a specific point of emphasis on a page, and that's basically impossible in Markdown). Static website generators share a common problem with many software systems in our industry today: a design oriented around a specific use case has a few configuration parameters, then slowly starts to accumulate more and more as more users request features or offer up PRs for their particular use cases. The result is software that has a vast and completely inexpressive configuration surface area.

]//ðŸ”š

âœ³//[:section {:class "point"}

âœ³=[:h4 "As is the custom of our profession, I must rely on a Lisp snowclone" ]ðŸ”š
âœ³=[:blockquote {:style (style {:font-size "1.5em" :line-height "1.25em"})}
"Any sufficiently advanced static website generator is an ad-hoc, unspecified, error-prone implementation of half of a graph database and a query language."]ðŸ”š

]//ðŸ”š

âœ³//[:section {:class "point"}
âœ³=[:h4 "A way out" ]ðŸ”š
I wanted to avoid this, so I decided to be as explicit as possible about the fact that state needs a database to live in. Fabricate, as a library, doesn't contain a database yet. I wrote its core data model and event loop using a FSM because that supported extension, âœ³=[:em "at runtime"]ðŸ”š, to include a DB. This way I could experiment, using my own website's code, without prematurely settling on a a model that freezes the database's role in the application.

I realized later on that you can put a finite state machine âœ³=[:em "in"]ðŸ”š  your database and change the behavior of your program via a database query! That intuitively sounded like a much better way of enforcing consistency guarantees on configuration changes than plaintext "configuration as code" approaches like YAML, so I decided to pursue it further.

]//ðŸ”š

âœ³//[:section {:class "point"}
âœ³=[:h4 "How does this not turn into an unmanageable mess?"]ðŸ”š
With practice.

But âœ³=[:code "malli"]ðŸ”š helps too. âœ³=[:code "malli"]ðŸ”š is a data validation and parsing library for Clojure that allows you to specify validation schemas using a syntax similar to âœ³=[:code "hiccup"]ðŸ”š, allowing its users to treat specifications as data. Like âœ³=[:code "spec"]ðŸ”š, which inspired it, it overlaps in some of its capabilities with a dependent type system, but can be deployed dynamically at compile, dev, or runtime.

Asami doesn't enforce a schema, so âœ³=[:code "malli"]ðŸ”š data schemas can put a fence around certain types of state modifications and also give end users a guide to the signature of the functions they need to use to play nicely in Fabricate's yard.

]//ðŸ”š

âœ³//[:section {:class "point"}
âœ³=[:h4 "For the non-Clojurians" ]ðŸ”š
Hiccup is a widely used library in Clojure that lets programmers represent HTML as vectors. Each tag is represented by a keyword element at the begnning of the vector, the attributes are represented by an optional associative array, and the contents are entries in the vector. It works like this:

âœ³= [:code "[:div {:class \"element-class\" :id \"203cd83\"} \"The div contents\"]"] ðŸ”š


âœ³= [:code (escape-html (html {:escape-strings? true} [:div {:class "element-class" :id "203cd83"} "The div contents"])) ] ðŸ”š

]//ðŸ”š

âœ³//[:section {:class "point"}
âœ³=[:h4 "The database" ]ðŸ”š
Fabricate uses a datalog-based schemaless database called âœ³=[:a {:href "https://github.com/threatgrid/asami"} [:code "Asami"]]ðŸ”š. The documentation for it is some of the best I've ever seen on the topic of graph databases, and its schemaless design is nice for storing things like arbitrary HTML/Hiccup data structures. I also strongly recommend the âœ³=[:a {:href "https://www.youtube.com/watch?v=-XegX_K6w-o"} "talks"]ðŸ”š given by Paula Gearon, Asami's author, about Asami's design and rationale.

My website's content, after being parsed into Clojure/Hiccup data structures, gets persisted in Asami, which is flexible enough to support the storage and querying of arbitrary HTML elements.

]//ðŸ”š

âœ³//[:section {:class "point"}
âœ³=[:h4 "Leveraging the database" ]ðŸ”š
I can use this capability to build out a quotes page (it's not as good as Bret Victor's). What's interesting about it is that it's generated programmatically from all the other pages on my site by annotating quotes with a specific HTML attribute.


âœ³+= (archive/query->table
    '[:find
      ?title ?q
      :where
      [?p :respatialized.writing/title ?title]
      [?p ?a* ?e]
      [?e :html.attribute.data/include true]
      (or [?e :html/tag :blockquote]
          [?e :html/tag :q])
      [?e ?a2* ?q]
      [(string? ?q)]]
    (d/db archive/test-db)
    {:col-renames {'?title "Title" '?fp "input file path" '?q "Quote contents"}})ðŸ”š


]//ðŸ”š

âœ³//[:section {:class "point"}
âœ³=[:h4 "But isn't that just one thing?" ]ðŸ”š
âœ³=[:aside [:em "Hugo has way more shortcodes for that kind of thing" ]]ðŸ”š


Well, yeah. I know. I didn't want to force fabricate's (still entirely hypothetical) userbase to memorize a bunch of annoying configuration like âœ³=[:pre [:code "site.fabricate.settings.include-quotes:" [:br]  "  true"]]ðŸ”š due to my lingering YAML grudge. As I mentioned before, database queries and finite state machines allow for âœ³=[:em "arbitrary runtime extension"]ðŸ”š  of Fabricate's capabilities. It runs inside your Clojure process, so you can write pages that depend on the contents of the database (like the quotes page).

You can write pages that automatically rerender when they detect changes to a subfolder of artworks and generate a nice-looking gallery for those artworks.

You can do whatever you want because - to quote Matthew Butterick - âœ³=[:q [:em "the book is a program"]]ðŸ”š.
]//ðŸ”š


âœ³//[:section {:class "point"}
âœ³=[:h4 "Demo" ]ðŸ”š
I'm going to modify the query to include âœ³=[:em "all"]ðŸ”š  quotes, not just those with the  âœ³=[:code "include"]ðŸ”š attribute.


âœ³+=
[:div {:style (style {:height "12em" :overflow "auto"})}
(archive/query->table
    '[:find
         ?title ?q
         :where
         [?p :respatialized.writing/title ?title]
         [?p ?a* ?e]
         (or [?e :html/tag :blockquote]
             [?e :html/tag :q])
         [?e ?a2* ?q]
         [(string? ?q)]]
    (d/db archive/test-db)
    {:col-renames {'?title "Title" '?fp "input file path" '?q "Quote contents"}})]ðŸ”š

]//ðŸ”š

âœ³//[:section {:class "point"}
âœ³=[:h4 "Conclusion" ]ðŸ”š

I already got some more ideas for refining the queries I use: I could identify quotes I repeat across pages; I could condense the sub-elements of each quote into a single string for search purposes, or I could query the contents of a page and return them in a random order for an exercise in aleatoric writing.

I hope you have found this talk interesting, and that it has given you other ideas about how you might use a database as a tool for writing documents, not just for storing them.

]//ðŸ”š
