
âœ³(ns respatialized.writing.boxed-int-libpython-clj)ðŸ”š
âœ³(def metadata {:title "Working with large integers in libpython-clj"})ðŸ”š


âœ³=[:h1 (:title metadata)]ðŸ”š

âœ³= [:h2 "Context"]ðŸ”š

âœ³=[:a {:href "https://github.com/clj-python/libpython-clj"}
 [:code "libpython-clj"]]ðŸ”š is an enormously useful library for bridging the Python and Clojure (and Java) worlds. Its data-oriented interface to Python classes and objects makes discovering features of Python libraries simple and convenient from a Clojure REPL. This article documents a problem I encountered when using it recently and the solution I put together for it.



âœ³+(require
  '[libpython-clj2.python :as py :refer [py. py.. py.-]]
  '[libpython-clj2.require :refer [require-python]])ðŸ”š
âœ³+(require-python '[builtins :as python])ðŸ”š

âœ³= [:h3 "The problem"]ðŸ”š
I was unable to successfully convert very large integer values - those larger than can be represented by a signed 64-bit integer - between Python and Clojure. Here's an example: 

âœ³= [:h5 "Python -> Clojure: Overflow"]ðŸ”š
âœ³+= (-> 29389942368720948710978341 str py/as-python python/int py/as-jvm)ðŸ”š

âœ³= [:h5 "Clojure -> Python: Error"]ðŸ”š
âœ³+= (try (libpython-clj2.python.copy/->py-long 29389942368720948710978341)
        (catch java.lang.IllegalArgumentException e
          [:pre [:code {:class "language-clojure"} (select-keys (Throwable->map e) [:cause :via])]])) ðŸ”š
          

âœ³= [:h3 "Background"]ðŸ”š


In version 3 onwards of Python, integer values are arbitrarily sized. On the JVM, integer values larger than 64 bits can be represented by âœ³= [:code "clojure.lang.BigInt"] ðŸ”š or âœ³= [:code "java.math.BigInteger"]ðŸ”š objects. However, despite being supported on both platforms, the copy pathway used by âœ³=[:code "libpython-clj"]ðŸ”š defaults to converting Python ints to 64-bit integers, resulting in the overflow seen above.

When converting numeric JVM types to Python types, integers get cast to âœ³=[:code "Long"]ðŸ”š (e.g. 64-bit - Clojure's default for integers) values, triggering the exception seen above.


âœ³=[:h3 "Creating a workaround"]ðŸ”š

The solution suggested to me by âœ³=[:a {:href "https://github.com/cnuernber/"} "Chris Nuernberger"]ðŸ”š, the author of âœ³=[:code "libpython-clj"]ðŸ”š, was to create a custom Python class for the integer values I needed to work with - effectively my own âœ³=[:a {:href "https://stackoverflow.com/a/1418302"} "boxed integer."]ðŸ”š This would allow me to bypass âœ³=[:code "libpython-clj"]ðŸ”š's default conversion pathways.


âœ³=[:h5 "Python class definition"]ðŸ”š
âœ³(def boxed-int-class-str
  "Python class definition for Boxed integer type to ensure integer values larger than 64 bits can be successfully passed across the Python <> JVM boundary."

  "class BoxedInt(int):

    def __init__(self, num):
        self.num = num

    def __call__(self, arg):
        '''Initialize the value. Optionally converts from string.'''
        if(type(arg) == str):
            self.num = int(arg)
        else:
            self.num = arg

    def __int__(self):
        return(self.num)

    def __str__(self):
        return(str(self.num))

    def __repr__(self):
        return('BoxedInt(' + str(self.num) + ')' )")ðŸ”š
        âœ³= [:pre [:code {:class "language-python"} boxed-int-class-str]]ðŸ”š


Because strings convert to and from Python in an identical manner, they can be used as an escape hatch for conversion for values larger than the natively-supported âœ³=[:code ":int64"]ðŸ”š datatype. To make sure that the class behaves in a manner consistent with other integers in Python (e.g. it can be used for selection, slicing, etc), the âœ³=[:code "BoxedInt"]ðŸ”š class inherits from the built-in âœ³=[:code "int"]ðŸ”š type.


Executing this Python code string creates an environment that a reference to the Python class object can be extracted from:

âœ³+
(def boxed-py-int
  (get-in
   (py/run-simple-string  boxed-int-class-str ) [:globals :BoxedInt])) ðŸ”š
   
With this class defined, libpython-clj provides the rest of the elements necesssary for a solution through the multimethods and protocols defined in the âœ³[:code "libpython-clj2.python.protocols"]ðŸ”š namespace.

This multimethod dispatches on the Python type of the object, allowing for the construction of a âœ³=[:code "BigInt"]ðŸ”š from the âœ³= [:code "BoxedInt"]ðŸ”š's string representation.

âœ³+(defmethod py-proto/pyobject->jvm :boxed-int
   [pyobj & args] (bigint (py/as-jvm (python/str pyobj))))ðŸ”š
   

Going the other way, the âœ³= [:code "PCopyToPython"]ðŸ”š protocol can be extended to new types, including the two JVM types used for larger-than-64-bit integers.

âœ³+ (extend-protocol py-proto/PCopyToPython
    clojure.lang.BigInt
    (py/->python [item opts] (boxed-py-int (str item)))
    java.math.BigDecimal
    (py/->python [item opts] (boxed-py-int (str item))))ðŸ”š
    
Another integer value can be used to verify the roundtrip behavior:

âœ³+(let [large-val 29289384293856920729839229839285108
       after-conv (-> large-val
                      py/->python
                      py/->jvm)]

   (assert (= large-val after-conv)
           "Values should successfully roundtrip to/from boxed int type"))ðŸ”š

âœ³= [:h4 "Concluding remarks"]ðŸ”š

When still working through this problem, I tried to define the BoxedInt class using âœ³=[:a {:href "https://clj-python.github.io/libpython-clj/libpython-clj2.python.html#var-create-class"} [:code "libpython-clj2.python/create-class"]]ðŸ”š, but I couldn't define the constructor and âœ³=[:code "__call__"]ðŸ”š methods using Clojure functions without again encountering the Python -> JVM conversion that prompted the overflow in the first place. Perhaps there's a way to achieve the same result using âœ³=[:code "create-class"]ðŸ”š that I couldn't figure out, but I knew I'd have complete control over the Python side of things by just using the class definition.

I was also struck by how well-designed âœ³=[:code "libpython-clj"]ðŸ”š is, and how comprehensible its codebase is. I was able to rework its behavior to operate on new data types by just reading through the implementations of multimethods and protocols it uses for its core data types. Though I struggled to solve this problem, it was never because it was difficult to figure out what âœ³=[:code "libpython-clj"]ðŸ”š was doing.

Thanks again to Chris Neurnberger for pointing me in the right direction on the Clojurians slack when I was still figuring out what to do.